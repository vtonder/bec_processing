import numpy as np
from kurtosis import spectral_kurtosis_cm
from matplotlib import pyplot as plt
from constants import a4_textwidth, a4_textheight, thesis_font
from scipy.stats import norm

# Chap 6.3.2 of "Digital Signal Processing" by JG Proakis and DG Manolakis

# Setup fonts and sizes for publication, based on page dimensions in inches
textwidth = a4_textwidth
textheight = a4_textheight
font_size = thesis_font
# groups are like plt.figure plt.legend etc
plt.rc('font', size=font_size, family='serif')
plt.rc('pdf', fonttype=42)
#plt.rc('axes', titlesize=14, labelsize=14)
plt.rc('axes', titlesize=font_size, labelsize=font_size)
plt.rc(('xtick', 'ytick'), labelsize=font_size)
plt.rc('legend', fontsize=font_size)
plt.rc('lines', markersize=5)
# The following should only be used for beamer
# plt.rc('figure', figsize=(0.9 * textwidth, 0.8 * textheight), facecolor='w')
figheight = 0.65 * textwidth
plt.rc('mathtext', fontset='cm')
# to get this working needed to do: sudo apt install cm-super
plt.rc("text", usetex = True)
plt.rc("figure", figsize = (textwidth, figheight))

M = 512
num_spectra = 10000
fft_len = 1024
mean = 0
std = 1

# 2's complement bit implementation. => 8 bits can be -128 to 127
num_bits = 8
v_max = 3*std # this is a 3sigma ito of std
num_quant_levels = (2**num_bits) - 1 # number of quantisation levels (number of intervals)
num_dec_levels = 2**num_bits # number of decision levels
mid = num_dec_levels / 2
step = 2*v_max / (2**num_bits)
quant_levels = np.arange(-mid*step + step, mid*step, step)
dec_levels = np.arange(quant_levels[0] + step/2, quant_levels[-1] + step/2, step)
# r_ is a concatenation functionality. can concatenate list and np.array
bins = np.r_[dec_levels[0] - step, dec_levels, dec_levels[-1] + step]

print("number of quantisation levels: ", num_quant_levels)
print("number of decision levels    : ", num_dec_levels)
print("mid                          : ", mid)
print("step                         : ", step)
print("q level 0                    : ", quant_levels[0])
print("q level -1                   : ", quant_levels[-1])
print(quant_levels)
print(dec_levels)

x_re = np.random.normal(mean, std, num_spectra*M)
xq_re = quant_levels[np.searchsorted(dec_levels, x_re)]
x_im = np.random.normal(mean, std, num_spectra*M)
xq_im = quant_levels[np.searchsorted(dec_levels, x_im)]

x = x_re + 1j*x_im
x = x.reshape(num_spectra, M)
xq = xq_re + 1j*xq_im
xq = xq.reshape(num_spectra, M)

sk = spectral_kurtosis_cm(x, M, fft_len)
skq = spectral_kurtosis_cm(xq, M, fft_len)

# ppf: Percent point function
x_val = np.linspace(norm.ppf(0.0001), norm.ppf(0.9999), 100)

fig, ax = plt.subplots()
# need to give hist the same bins that you used to generate the data
#ax.hist(x_re, 512, density=True, label="continuous")
ax.hist(xq_re, bins = bins, density = True, label = "8-bit quantisation")
ax.plot(x_val, norm.pdf(x_val), label = "Gaussian PDF", linewidth = 2)
ax.set_xlabel("real raw voltage values")
ax.set_ylabel("PDF")
ax.set_xlim([-3.5, 3.5])
ax.legend()
plt.savefig('/home/vereese/Documents/PhD/ThesisTemplate/Figures/quant_raw_v.pdf', transparent=True, bbox_inches='tight')
sk_x_val = np.arange(0, 2, 0.01)
# pdf_M512.npy was generated by sk/sk_thresholds.py
sk_pdf = np.load("/home/vereese/git/phd_data/sk_analysis/pdf_M512.npy")
mean_skq = np.round(np.mean(skq), 4)

fig1, ax1 = plt.subplots()
ax1.hist(sk, 200, density = True, alpha = 0.8, label=f"continuous")
ax1.semilogy(sk_x_val, sk_pdf, label = "Pearson type IV PDF", linewidth = 2)
ax1.hist(skq, 200, density = True, alpha = 0.8, label=f"8-bit quantisation")
ax1.vlines(x = mean_skq, ymin = 10**-1, ymax = 10, color='m', linewidth = 2, label = "$\overline{SK}_{\mbox{quantisation}}$")
ax1.set_xlabel("SK values")
ax1.set_ylabel("PDF")
ax1.set_xlim([0.7, 1.3])
ax1.set_ylim([10**-1, 10])
ax1.legend()
plt.savefig('/home/vereese/Documents/PhD/ThesisTemplate/Figures/quant_sk.pdf', transparent=True, bbox_inches='tight')
plt.show()
